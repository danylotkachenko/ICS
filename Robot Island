{Filename 	: TkaDanRobotDir}
{Program	:    }
{Outline 	     }
{            	 }
{Programmer 	: Danylo Tkachenko}
{Class	        : ICS3U (Mr.Sze)}
{Due Date	:  2017-10-27}
uses Crt, Graph;
var
i, j, icompass: integer;
ix, iy, ix2, iy2 : integer;
isteps_total, isteps, iavg, ilargest_number_of_steps, ismallest_number_of_steps : integer;
r : integer; //radius
leave_north, leave_south, leave_east, leave_west : integer;


gd,gm : smallint;

island : array[1..11] of array[1..11] of integer;  //11 by 11 field

function IsEndOfTheIslandReached (newX, newY: integer): boolean;
  begin
  if (newX = 12) or (newX = 0) or (newY = 12) or (newY = 0) then
       begin
            IsEndOfTheIslandReached := true;  //robot got off the island
       end
   else
       begin
            IsEndOfTheIslandReached := false;  //robot is still on the island
       end;

  end;

function CanIGoThisWay (newX, newY: integer): boolean;
  begin
  if island[newX][newY] = 0 then
       begin
            CanIGoThisWay := true;
       end
  else
      begin
             CanIGoThisWay := false;
      end;
  end;

procedure DisplayAMap;
          begin
               for i := 1 to 12 do
                   begin
                        MoveTo(40*i, 40);
                        LineTo(40*i, 480);
                        MoveTo(40, 40*i);
                        LineTo(480, 40*i);
                   end;
          end;

procedure DrawARobot (var RobotX, RobotY, Radius : integer);
          begin
               circle(40+20+(RobotX-1)*40, 40+20+(RobotY-1)*40, Radius);
          end;

procedure DrawAnObstacle (var ObstacleX, ObstacleY : integer);
          begin
               Rectangle(40+20+(ObstacleX-1)*40-15, 40+20+(ObstacleY-1)*40-15,40+20+(ObstacleX-1)*40+15, 40+20+(ObstacleY-1)*40+15)
          end;

begin
gd:=detect;
gm:=0;
InitGraph(gd,gm, 'c:\dev-pas');

leave_north := 0;
leave_south := 0;
leave_east  := 0;
leave_west  := 0;

ilargest_number_of_steps := 0;
ismallest_number_of_steps := 99999999;

for i := 1 to 11 do
    for j := 1 to 11 do
        begin
             island[i][j] := 0;
        end;

//Obstacles begin
island[3][5] := 2;
island[8][2] := 2;
island[5][10] := 2;
island[1][1] := 2;
island[11][8] := 2;
island[7][6] := 2;
island[9][3] := 2;
island[2][4] := 2;
island[4][7] := 2;
island[6][9] := 2;
island[10][11] := 2;
//Obstacles end

for i := 1 to 11 do
    for j := 1 to 11 do
        begin
             if island [i][j] = 2 then
                begin
                     DrawAnObstacle(i,j);
                end;
        end;

randomize;

DisplayAMap;

for i := 1 to 20 do
begin
isteps := 0;
ix := 6;
iy := 6;
writeln ('');
writeln ('                                       TRY #', i);
r := 20 - {3*}i;
DrawARobot(ix, iy, r);
delay (1500);

//ROBOT BEGINS MOVING
repeat
      begin
           icompass:= Random(4)+1;
                  if icompass = 1 then //right
                     begin
                          ix2 := ix + 1;
                          iy2 := iy;
                     end;
                  if icompass = 2 then //left
                     begin
                          ix2 := ix - 1;
                          iy2 := iy;
                     end;
                  if icompass = 3 then //down
                     begin
                          ix2 := ix;
                          iy2 := iy + 1;
                     end;
                  if icompass = 4 then //up
                     begin
                          ix2 := ix;
                          iy2 := iy - 1;
                     end;

                  if (IsEndOfTheIslandReached(ix2, iy2) = true) then
                     begin

                          ix := ix2;
                          iy := iy2;
                     //CALCULATES NUMBER OF TIMES ROBOT LEFT THROUGH EACH SIDE OF THE FIELD
                          if ix = 0 then
                             begin
                                  leave_west := leave_west + 1;
                             end;
                          if ix = 12 then
                             begin
                                  leave_east := leave_east + 1;
                             end;
                          if iy = 0 then
                             begin
                                  leave_north := leave_north + 1;
                             end;
                          if iy = 12 then
                             begin
                                  leave_south := leave_south + 1;
                             end;
                     //CALCULATES NUMBER OF TIMES ROBOT LEFT THROUGH EACH SIDE OF THE FIELD

                          isteps := isteps + 1;
                          isteps_total := isteps_total + 1;

                          // FINDS LARGEST NUMBER
                          if isteps > ilargest_number_of_steps then
                             begin
                                  ilargest_number_of_steps := isteps;
                             end;
                          // FINDS LARGEST NUMBER

                          // FINDS SMALLEST NUMBER
                          if isteps < ismallest_number_of_steps then
                             begin
                                  ismallest_number_of_steps := isteps;
                             end;
                          // FINDS SMALLEST NUMBER
                          writeln ('ROBOT GOT OFF THE ISALND');
                          writeln ('');
                     end
                  else
                     begin

                          if CanIGoThisWay(ix2, iy2) then
                             begin
                                  ix := ix2;
                                  iy := iy2;
                                  DrawARobot(ix, iy, r);
                                  delay (75);
                                  isteps := isteps + 1;
                                  isteps_total := isteps_total + 1;
                                  writeln ('x - ',ix,', ','y - ',iy);
                                  writeln ('');
                             end
                          else
                             begin
                                  writeln ('THERE IS AN OBSTACLE IN YOUR WAY.');
                                  writeln ('');
                             end;
                     end;
      end;
until (IsEndOfTheIslandReached(ix, iy) = true);
//ROBOT STOPS MOVING
end;

iavg := isteps_total div 20;
writeln ('');
writeln ('On average, it took the robot ', iavg, ' steps to leave the island.');
writeln ('Smallest # of steps ', ismallest_number_of_steps);
writeln ('Largest # of steps ', ilargest_number_of_steps);
writeln ('');
writeln ('Below is a table that lists who many times robot used each side of');
writeln ('the island to leave:');
writeln ('Northen side - ',leave_north);
writeln ('Eastern side - ', leave_east);
writeln ('Southern - ', leave_south);
writeln ('Western - ', leave_west);

readln ();
CloseGraph;
end.
